// Code generated by api_wrapper_code_generator. DO NOT EDIT.
// NOT THREAD SAFE
package {{.Pkg}}

import (
	"context"
	"fmt"
	"github.com/f0mster/micro/client"
	"github.com/f0mster/micro/interfaces/contextmarshaller"
	"github.com/f0mster/micro/pkg/rnd"
	"github.com/f0mster/micro/pubsub"
	"github.com/f0mster/micro/registry"
	"github.com/f0mster/micro/server"
	"sync/atomic"
)
{{range $serviceName, $service := .Services}}
type {{$serviceName}} interface {
	{{- range $index, $rpc := $service.Rpc}}
	{{ if $rpc.Comments }}
	{{- range $i, $c := $rpc.Comments }}
	//{{$c}} 
	{{- end -}}
	{{- end }}
	{{$rpc.Name}}(ctx context.Context, req *{{$rpc.Request}}) (resp *{{$rpc.Response}}, err error)
	{{- end}}
}
{{end}}

{{- range $serviceName, $service := .Services}}
type {{$serviceName|Title}}Service struct {
	handler    {{$serviceName}}
	config     server.Config
	instanceId string
	started    int32
	stopListen context.CancelFunc
	publisher  *{{$serviceName|Title}}EventsPublisher
}

func (h *{{$serviceName}}Service) GetInstanceId() string {
	return h.instanceId
}

/*
func Register{{$serviceName|Title}}ServerWithOptions(service {{$serviceName}}, opts ... server.Option) *{{$serviceName|Title}}Server {
	//TODO
}
*/

func Register{{$serviceName|Title}}Server(handler {{$serviceName}}, srv *server.Server) (*{{$serviceName|Title}}Service, error) {
	insId, err := rnd.GenerateRandomString(20)
	if err != nil {
		return nil, err
	}
	cfg, err := srv.GetConfig()
	if err != nil {
		return nil, err
	}
	ins := &{{$serviceName}}Service{
		handler:    handler,
		instanceId: insId,
		config:     cfg,
		publisher:  New{{$serviceName|Title}}EventsPublisher(cfg.PubSub),
	}
	ins.publisher.SetContextMarshaller(cfg.ContextMarshaller)
	ins.publisher.SetWrapper(cfg.PubSubWrapper)

	str := starter{{$serviceName|Title}}{ins: ins}
	err = srv.Register(&str)
	if err!= nil {
		return nil, err
	}

	return ins, nil
}

type starter{{$serviceName|Title}} struct {
	ins *{{$serviceName}}Service
}

func (s *starter{{$serviceName|Title}}) Start() {
	s.ins.stopListen = s.ins.config.RPC.Listen("{{$serviceName}}", s.ins.listenRPC)
	s.ins.config.Registry.Register("{{$serviceName}}", registry.InstanceId(s.ins.instanceId))
	atomic.StoreInt32(&s.ins.started, 1)
}

func (s *starter{{$serviceName|Title}}) Stop() {
	if atomic.LoadInt32(&s.ins.started) == 0 {
		return
	}
	s.ins.config.Registry.Unregister("{{$serviceName}}", registry.InstanceId(s.ins.instanceId))
	s.ins.stopListen()
	atomic.StoreInt32(&s.ins.started, 0)
}

// watch on service instance register
func (c *{{$serviceName|Title}}Service) WatchInstanceRegistered(callback func(instanceId registry.InstanceId)) registry.CancelFunc {
	return c.config.Registry.WatchInstanceRegistered("{{$serviceName}}", callback)
}

// watch on service instance unregister
func (c *{{$serviceName|Title}}Service) WatchInstanceUnregistered(callback func(instanceId registry.InstanceId)) registry.CancelFunc {
	return c.config.Registry.WatchInstanceUnregistered("{{$serviceName}}", callback)
}

{{- range $index, $event := $service.Events}}
func (s *{{$serviceName}}Service) Publish{{$event|Title}}(ctx context.Context, event *{{$event}}) error {
	return s.publisher.Publish{{$event|Title}}(ctx, event)
}
{{- end}}

func (h *{{$serviceName}}Service) listenRPC(funcName string, ctx []byte, arguments []byte) (r []byte, err error) {
	pCtx, _, err := h.config.ContextMarshaller.Unmarshal(ctx)
	if err != nil {
		return nil, err
	}

	callRpc := func(ctx context.Context) error {
		{{ if eq (len $service.Rpc) 0 }}
		return  fmt.Errorf("service have no rpcs")
		{{ else }}
		switch funcName {
		{{- range $index, $rpc := $service.Rpc}}
		case "{{$rpc.Name}}":
			arg := {{$rpc.Request}}{}
			err = arg.Unmarshal(arguments)
			if err != nil {
				return err
			}

			var resp *{{$rpc.Response}}
			resp, err = h.handler.{{$rpc.Name}}(ctx, &arg)
			if err != nil {
				return err
			}
			
			// XXX: avoid nil panic if handler returned <nil, nil>.
			if resp == nil {
				resp = new({{$rpc.Response}})
			}

			r, err = resp.Marshal()
			if err != nil {
				return err
			}
			return nil
		{{- end}}
		default:
			//TODO: not sure about this behavior
			return fmt.Errorf("call of unknown rpc %s %s", "in service {{$serviceName}} ", funcName)
		}
		{{ end }}
	}

	wrap := h.config.RPCWrapper
	if wrap != nil {
		err = wrap(pCtx, "{{$serviceName}}", funcName, callRpc)
		if err != nil {
			return nil, err
		}
		return r, nil
	} 

	err = callRpc(pCtx)
	if err != nil {
		return nil, err
	}

	return r, nil
}

// 
// Event publisher
//

type PubSubWrap func(ctx context.Context, serviceName, eventName string, PubSubWrapper func(ctx context.Context) error) error
type {{$serviceName|Title}}EventsPublisher struct {
	ps pubsub.PubSub
	cm contextmarshaller.ContextMarshaller
	wrapper PubSubWrap
}

func New{{$serviceName|Title}}EventsPublisher(ps pubsub.PubSub) *{{$serviceName|Title}}EventsPublisher {
	return &{{$serviceName|Title}}EventsPublisher{
		ps: ps,
		cm: &contextmarshaller.DefaultCtxMarshaller{},
	}
}

func (s *{{$serviceName|Title}}EventsPublisher) SetContextMarshaller(cm contextmarshaller.ContextMarshaller) {
	s.cm = cm
}

func (s *{{$serviceName|Title}}EventsPublisher) SetWrapper(PubSubWrapper func(ctx context.Context, ServiceName, EventName string, PubSubCall func(ctx context.Context) error) error) {
	s.wrapper = PubSubWrapper
}

{{- range $index, $event := $service.Events}}
func (s *{{$serviceName|Title}}EventsPublisher) Publish{{$event|Title}}(ctx context.Context, event *{{$event}}) error {
	var r []byte
	var err error
	if event != nil {
		r, err = event.Marshal()
		if err != nil {
			return fmt.Errorf("can't marshal event to proto: %w", err)
		}
	}
	cb := func (ctx context.Context) error {
		ctxData, err := s.cm.Marshal(ctx)
		if err != nil {
			return fmt.Errorf("can't marshal context data: %w", err)
		}
	
		err = s.ps.Publish("{{$serviceName}}", "{{$event}}", ctxData, r)
		if err != nil {
			return fmt.Errorf("error while publishing error: %w",err)
		}
	
		return nil
	}

	if s.wrapper == nil {
		return cb(ctx)
	}
	return s.wrapper(ctx, "{{$serviceName}}", "{{$event}}", cb)
}
{{- end}}

//
// Client
//

type {{$serviceName}}Client struct {
	client			*client.Client
	block           bool
}

func New{{$serviceName|Title}}Client(config client.Config, opt ...ClientOpt) (*{{$serviceName}}Client, error) {
	cClient, err := client.NewClient(config)
	if err != nil {
		return nil, err
	}
	cli := &{{$serviceName}}Client{
		client: cClient,
	}
	for _, o := range opt {
		o(cli)
	}

	if cli.block {
		cli.client.WaitForServiceStarted("{{$serviceName}}")
	}

	return cli, nil
}

type ClientOpt func(c *{{$serviceName}}Client)

func WithBlock() ClientOpt {
	return func(c *{{$serviceName}}Client) {
		c.block = true
	}
}

// watch on service register
func (c *{{$serviceName}}Client) WatchRegistered(callback func()) registry.CancelFunc {
	return c.client.GetConfig().Registry.WatchRegistered("{{$serviceName}}", callback)
}

// watch on service unregister
func (c *{{$serviceName}}Client) WatchUnregistered(callback func()) registry.CancelFunc {
	return c.client.GetConfig().Registry.WatchUnregistered("{{$serviceName}}", callback)
}

{{- range $index, $rpc := $service.Rpc}}

{{ if $rpc.Comments }}
{{- range $i, $c := $rpc.Comments }}
//{{$c}} 
{{- end -}}
{{- end }}
func (c *{{$serviceName}}Client) {{$rpc.Name}}(ctx context.Context, request *{{$rpc.Request}}, callOpts ...client.CallOption) (response *{{$rpc.Response}}, err error) {
	response = &{{$rpc.Response}}{}
	err = c.client.CallWithMarshaller(ctx, "{{$serviceName}}", "{{$rpc.Name}}", request, response, callOpts...)
	if err != nil {
		return nil, err
	}

	return response, nil
}
{{- end}}

{{- range $index, $event := $service.Events}}

func (c *{{$serviceName}}Client) Unsubscribe{{$event|Title}}() {
	c.client.Unsubscribe("{{$serviceName}}", "{{$event}}")
}

// Nil error in callback required to stop event retrying, if it supported by pubsub provider
func (c *{{$serviceName}}Client) Subscribe{{$event|Title}}(callback func(ctx context.Context, event *{{$event}}) error) (stop pubsub.CancelFunc, err error) {
	stop, err = c.client.GetConfig().PubSub.Subscribe("{{$serviceName}}", "{{$event}}", func(ctxData, event []byte) error {
		log := c.client.GetConfig().Logger
		ev := {{$event}}{}
		err := ev.Unmarshal(event)
		log.Debug("got event", "{{$serviceName}}", "{{$event}}")
		if err != nil {
			log.Error(err, "error while unmarshalling event", "{{$serviceName}}", "{{$event}}", string(event))
			return fmt.Errorf("error while unmarshalling event: %w", err)
		}
		ctx, _, err := c.client.GetConfig().ContextMarshaller.Unmarshal(ctxData)
		if err != nil {
			log.Error(err, "error while unmarshalling context data", "{{$serviceName}}", "{{$event}}", string(ctxData))
			return fmt.Errorf("error while unmarshalling context data: %w", err)
		}
		wrap := c.client.GetConfig().PubSubWrapper
		if wrap != nil {
			wrapCB := func(ctx context.Context) error {
				err = callback(ctx,&ev)
				if err != nil {
					return fmt.Errorf("error while calling subscribe callback: %w", err)
				}
				return nil
			}
			err = wrap(ctx, "{{$serviceName}}", "{{$event}}", wrapCB)
			return err
		}
		err = callback(ctx,&ev)
		if err != nil {
			return fmt.Errorf("error while calling subscribe callback: %w", err)
		}
		return nil
	})

	return stop, err
}
{{- end}}
{{- end}}
