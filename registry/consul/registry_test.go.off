package counsul_test

import (
	"bytes"
	"context"
	"fmt"
	"github.com/ory/dockertest/v3"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/require"
	"io"
	"os"
	"strings"
	"sync"
	"testing"
	"time"
)

/*
  Внимание!

  Для запуска необходим docker.

  Адрес указывается через переменную окружения DOCKER_HOST.

*/

var appIndex int32

type TestContext struct {
	consulAddr string

	dockerPool *dockertest.Pool
	dbRes      *dockertest.Resource

	ctx       context.Context
	ctxCancel func()
	logWG     sync.WaitGroup
}

func getAddr(dockerEndpoint, port string) string {
	// experimental support of local docker daemon
	dockerEndpoint = strings.Replace(dockerEndpoint, "tcp://", "", 1)

	host := strings.Split(dockerEndpoint, ":")[0]

	if strings.Contains(dockerEndpoint, "unix:") || strings.Contains(dockerEndpoint, "http://localhost:") {
		host = "0.0.0.0"
	}

	return fmt.Sprintf(
		"%s:%s",
		host,
		port)
}

func (tc *TestContext) SetUp(t testing.TB) {
	tc.ctx, tc.ctxCancel = context.WithCancel(context.Background())

	t.Log("SetUp")
	//if os.Getenv("DOCKER_HOST") == "" {
	//	fmt.Println("Specify env DOCKER_HOST")
	//	os.Exit(1)
	//}

	// uses a sensible default on windows (tcp/http) and linux/osx (socket)
	if p, e := dockertest.NewPool(""); e != nil {
		t.Fatalf("Could not connect to docker: %s", e)
	} else {
		tc.dockerPool = p
	}

	// pulls an image, creates a container based on it and runs it
	//consulconfig, err := DefaultConsulLocalConfig()
	//require.NoError(t, err)
	//port := RandomPort()
	//forward := fmt.Sprintf("%d:%d", port, 8500)
	if r, e := tc.dockerPool.RunWithOptions(&dockertest.RunOptions{
		Repository: "consul",
		Tag:        "1.8.5",
		////		Env:        []string{"CONSUL_LOCAL_CONFIG=" + consulconfig},
		//Cmd: []string{
		//	"--name", GenerateContainerID(),
		//	"-d",
		//	"-p", forward,
		//	"-e", fmt.Sprintf("CONSUL_LOCAL_CONFIG=%s", consulconfig),
		//	env.Getenv("DOCKERTEST_CONSUL_IMAGE_NAME", "consul"),
		//	"agent",
		//	"-dev", // Run in dev mode
		//	"-client", "0.0.0.0",
		//},
	}); e != nil {
		t.Fatalf("Could not start resource: %s", e)
	} else {
		tc.dbRes = r
	}

	// exponential backoff-retry, because the application in the container might not be ready to accept connections yet
	tc.consulAddr = getAddr(tc.dockerPool.Client.Endpoint(), tc.dbRes.GetPort("8500/tcp"))
	if err := tc.dockerPool.Retry(func() error {
		config := api.DefaultConfig()
		config.Address = tc.consulAddr

		k := "somekey"
		v := "somevalue"
		fmt.Println("retry")
		client, err := api.NewClient(config)
		p := &api.KVPair{Key: k, Value: []byte(v)}
		kv := client.KV()
		_, err = kv.Put(p, nil)
		if err != nil {
			return err
		}
		if err != nil {
			return err
		}
		_ = client.Connect()
		return nil
	}); err != nil {
		t.Fatalf("Could not connect to docker: %s", err)
	}

	// app logging

	zerolog.SetGlobalLevel(zerolog.FatalLevel)
	if os.Getenv("DEBUG") != "" {
		zerolog.SetGlobalLevel(zerolog.DebugLevel)
	}

	// pipe logging to t.Log
	b := bytes.NewBuffer(nil)

	tc.logWG.Add(1)
	go func() {
		defer tc.logWG.Done()

		readAllAndExit := false

		for {
			l, e := b.ReadString('\n')
			if e != nil && e != io.EOF {
				t.Fatal("log piping error: ", e)
			}
			if e == io.EOF && readAllAndExit {
				return
			}
			if l != "" {
				t.Log(strings.TrimRight("[LOG] "+l, "\n"))
			}

			if readAllAndExit {
				continue
			}

			select {
			case <-tc.ctx.Done():
				readAllAndExit = true
				continue
			default:

			}
			time.Sleep(1 * time.Millisecond)
		}
	}()
}

func (tc *TestContext) TearDown(t testing.TB) {
	t.Log("TearDown")

	tc.ctxCancel()

	if err := tc.dockerPool.Purge(tc.dbRes); err != nil {
		t.Fatalf("Could not purge resource: %s", err)
	}
	tc.dbRes = nil

	tc.logWG.Wait()
}

func TestRegistry_Call(t *testing.T) {
	tctx := TestContext{}
	tctx.SetUp(t)
	defer tctx.TearDown(t)
	config := api.DefaultConfig()
	config.Address = tctx.consulAddr

	client, err := api.NewClient(config)
	s, err := connect.NewService("my-service", client)
	s.Ready()
	client.Connect()
	client2, err := api.NewClient(config)
	connect.NewService("my-service2", client2)

	require.NoError(t, err)
	_ = client2.Agent()
	agent := client.Agent()
	c := client.Catalog()
	c.Services()
	a, _ := agent.Services()
	agent.ServiceRegister()
	fmt.Println(len(a))
	for i := range a {
		fmt.Println(a[i].Namespace, a[i].ID)
	}
	kv := client.KV()
	// PUT a new KV pair
	k := "somekey"
	v := "somevalue"
	p := &api.KVPair{Key: k, Value: []byte(v)}
	_, err = kv.Put(p, nil)
	require.NoError(t, err)
	pair, _, err := kv.Get(k, nil)
	require.Equal(t, v, string(pair.Value))
	t.Log("ok")
	return

}
